// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

package do

import (
	"bytes"
	"database/sql"
	"errors"
	"github.com/linbaozhong/gentity/example/model/define/table/tblapp"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
	"github.com/linbaozhong/gentity/pkg/ace/pool"
	"github.com/linbaozhong/gentity/pkg/api/broker"
	"github.com/linbaozhong/gentity/pkg/gjson"
	"github.com/linbaozhong/gentity/pkg/log"
	"github.com/linbaozhong/gentity/pkg/types"
)

const AppTableName = "app"

var (
	appPool = pool.New(broker.Context, func() any {
		obj := &App{}
		obj.UUID()
		return obj
	})
)

func NewApp() *App {
	obj := appPool.Get().(*App)
	return obj
}

// MarshalJSON
func (p *App) MarshalJSON() ([]byte, error) {
	var buf = bytes.NewBuffer(nil)
	buf.WriteByte('{')
	if p.Id != 0 {
		buf.WriteString(`"id":` + types.Marshal(p.Id) + `,`)
	}
	if p.Arch != "" {
		buf.WriteString(`"arch":` + types.Marshal(p.Arch) + `,`)
	}
	if p.Version != "" {
		buf.WriteString(`"version":` + types.Marshal(p.Version) + `,`)
	}
	if p.Url != "" {
		buf.WriteString(`"url":` + types.Marshal(p.Url) + `,`)
	}
	if p.State != 0 {
		buf.WriteString(`"state":` + types.Marshal(p.State) + `,`)
	}
	if p.Force != 0 {
		buf.WriteString(`"force":` + types.Marshal(p.Force) + `,`)
	}
	if l := buf.Len(); l > 1 {
		buf.Truncate(l - 1)
	}
	buf.WriteByte('}')
	return buf.Bytes(), nil
}

// UnmarshalJSON
func (p *App) UnmarshalJSON(data []byte) error {

	ok := gjson.ValidBytes(data)
	if !ok {
		return errors.New("invalid json")
	}
	result := gjson.ParseBytes(data)
	result.ForEach(func(key, value gjson.Result) bool {
		var e error
		switch key.Str {
		case "id":
			e = types.Unmarshal(value, &p.Id, types.BigInt(value.Uint()))
		case "arch":
			e = types.Unmarshal(value, &p.Arch, types.String(value.Str))
		case "version":
			e = types.Unmarshal(value, &p.Version, types.String(value.Str))
		case "url":
			e = types.Unmarshal(value, &p.Url, types.String(value.Str))
		case "state":
			e = types.Unmarshal(value, &p.State, types.Int8(value.Int()))
		case "force":
			e = types.Unmarshal(value, &p.Force, types.Int8(value.Int()))
		}
		if e != nil {
			log.Error(e)
			return false
		}
		return true
	})
	return nil
}

// Free
func (p *App) Free() {
	if p == nil {
		return
	}

	appPool.Put(p)
}

// Reset
func (p *App) Reset() {
	p.Id = 0
	p.Arch = ""
	p.Version = ""
	p.Url = ""
	p.State = 0
	p.Force = 0

}

func (p *App) TableName() string {
	return AppTableName
}

func (p *App) AssignPtr(args ...dialect.Field) []any {
	if len(args) == 0 {
		args = tblapp.ReadableFields
	}

	vals := make([]any, 0, len(args))
	for _, col := range args {
		switch col {
		case tblapp.Id:
			vals = append(vals, &p.Id)
		case tblapp.Arch:
			vals = append(vals, &p.Arch)
		case tblapp.Version:
			vals = append(vals, &p.Version)
		case tblapp.Url:
			vals = append(vals, &p.Url)
		case tblapp.State:
			vals = append(vals, &p.State)
		case tblapp.Force:
			vals = append(vals, &p.Force)
		}
	}

	return vals
}

func (p *App) Scan(rows *sql.Rows, args ...dialect.Field) ([]App, bool, error) {
	defer rows.Close()
	apps := make([]App, 0)

	if len(args) == 0 {
		args = tblapp.ReadableFields
	}

	for rows.Next() {
		p := NewApp()
		vals := p.AssignPtr(args...)
		err := rows.Scan(vals...)
		if err != nil {
			log.Error(err)
			return nil, false, err
		}
		apps = append(apps, *p)
	}
	if err := rows.Err(); err != nil {
		log.Error(err)
		return nil, false, err
	}
	if len(apps) == 0 {
		return nil, false, sql.ErrNoRows
	}
	return apps, true, nil
}

func (p *App) AssignValues(args ...dialect.Field) ([]string, []any) {
	var (
		lens = len(args)
		cols []string
		vals []any
	)

	if len(args) == 0 {
		args = tblapp.WritableFields
		lens = len(args)
		cols = make([]string, 0, lens)
		vals = make([]any, 0, lens)
		for _, arg := range args {
			switch arg {
			case tblapp.Id:
				if p.Id == 0 {
					continue
				}
				cols = append(cols, tblapp.Id.Quote())
				vals = append(vals, p.Id)
			case tblapp.Arch:
				if p.Arch == "" {
					continue
				}
				cols = append(cols, tblapp.Arch.Quote())
				vals = append(vals, p.Arch)
			case tblapp.Version:
				if p.Version == "" {
					continue
				}
				cols = append(cols, tblapp.Version.Quote())
				vals = append(vals, p.Version)
			case tblapp.Url:
				if p.Url == "" {
					continue
				}
				cols = append(cols, tblapp.Url.Quote())
				vals = append(vals, p.Url)
			case tblapp.State:
				if p.State == 0 {
					continue
				}
				cols = append(cols, tblapp.State.Quote())
				vals = append(vals, p.State)
			case tblapp.Force:
				if p.Force == 0 {
					continue
				}
				cols = append(cols, tblapp.Force.Quote())
				vals = append(vals, p.Force)
			}
		}
		return cols, vals
	}

	cols = make([]string, 0, lens)
	vals = make([]any, 0, lens)
	for _, arg := range args {
		switch arg {
		case tblapp.Id:
			cols = append(cols, tblapp.Id.Quote())
			vals = append(vals, p.Id)
		case tblapp.Arch:
			cols = append(cols, tblapp.Arch.Quote())
			vals = append(vals, p.Arch)
		case tblapp.Version:
			cols = append(cols, tblapp.Version.Quote())
			vals = append(vals, p.Version)
		case tblapp.Url:
			cols = append(cols, tblapp.Url.Quote())
			vals = append(vals, p.Url)
		case tblapp.State:
			cols = append(cols, tblapp.State.Quote())
			vals = append(vals, p.State)
		case tblapp.Force:
			cols = append(cols, tblapp.Force.Quote())
			vals = append(vals, p.Force)
		}
	}
	return cols, vals
}

func (p *App) AssignKeys() (dialect.Field, any) {
	return tblapp.PrimaryKey, p.Id
}

func (p *App) AssignPrimaryKeyValues(result sql.Result) error {
	return nil
}
