// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

package do

import (
	"bytes"
	"database/sql"
	"errors"
	"github.com/linbaozhong/gentity/example/model/define/table/tbluser"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
	"github.com/linbaozhong/gentity/pkg/ace/pool"
	"github.com/linbaozhong/gentity/pkg/app"
	"github.com/linbaozhong/gentity/pkg/gjson"
	"github.com/linbaozhong/gentity/pkg/log"
	"github.com/linbaozhong/gentity/pkg/types"
)

const UserTableName = "user"

var (
	userPool = pool.New(app.Context, func() any {
		_obj := &User{}
		_obj.UUID()
		return _obj
	})
)

func NewUser() *User {
	_obj := userPool.Get().(*User)
	return _obj
}

// MarshalJSON
func (p *User) MarshalJSON() ([]byte, error) {
	var _buf = bytes.NewBuffer(nil)
	_buf.WriteByte('{')
	if p.Id != 0 {
		_buf.WriteString(`"id":` + types.Marshal(p.Id) + `,`)
	}
	if p.Uuid != "" {
		_buf.WriteString(`"uuid":` + types.Marshal(p.Uuid) + `,`)
	}
	if !p.Ctime.IsZero() {
		_buf.WriteString(`"ctime":` + types.Marshal(p.Ctime) + `,`)
	}
	if p.UserLogs != nil {
		_buf.WriteString(`"user_logs":` + types.Marshal(p.UserLogs) + `,`)
	}
	if l := _buf.Len(); l > 1 {
		_buf.Truncate(l - 1)
	}
	_buf.WriteByte('}')
	return _buf.Bytes(), nil
}

// UnmarshalJSON
func (p *User) UnmarshalJSON(data []byte) error {
	defer func() {
		if r := recover(); r != nil {
			log.Error(r)
			return
		}
	}()

	if !gjson.ValidBytes(data) {
		return errors.New("invalid json")
	}
	_result := gjson.ParseBytes(data)
	_result.ForEach(func(key, value gjson.Result) bool {
		var e error
		switch key.Str {
		case "id":
			e = types.Unmarshal(value, &p.Id, types.BigInt(value.Uint()))
		case "uuid":
			e = types.Unmarshal(value, &p.Uuid, types.String(value.Str))
		case "ctime":
			e = types.Unmarshal(value, &p.Ctime, types.Time{Time: value.Time()})
		case "user_logs":
			e = types.Unmarshal(value, &p.UserLogs, func(value gjson.Result) []UserLog {
				var obj []UserLog
				e := types.Unmarshal(value, &obj)
				if e != nil {
					panic(e)
				}
				return obj
			}(value))
		}
		if e != nil {
			log.Error(e)
			return false
		}
		return true
	})
	return nil
}

// Free
func (p *User) Free() {
	if p == nil {
		return
	}

	userPool.Put(p)
}

// Reset
func (p *User) Reset() {
	p.Id = 0
	p.Uuid = ""
	p.Ctime = types.Time{}
	p.UserLogs = p.UserLogs[:0]

}

func (p *User) TableName() string {
	return UserTableName
}

func (p *User) AssignPtr(args ...dialect.Field) []any {
	if len(args) == 0 {
		args = tbluser.ReadableFields
	}

	_vals := make([]any, 0, len(args))
	for _, col := range args {
		switch col {
		case tbluser.Id:
			_vals = append(_vals, &p.Id)
		case tbluser.Uuid:
			_vals = append(_vals, &p.Uuid)
		case tbluser.Ctime:
			_vals = append(_vals, &p.Ctime)
		case tbluser.UserLogs:
			_vals = append(_vals, &p.UserLogs)
		}
	}

	return _vals
}

func (p *User) Scan(rows *sql.Rows, args ...dialect.Field) ([]User, bool, error) {
	defer rows.Close()
	users := make([]User, 0)

	if len(args) == 0 {
		args = tbluser.ReadableFields
	}

	for rows.Next() {
		_p := NewUser()
		_vals := _p.AssignPtr(args...)
		e := rows.Scan(_vals...)
		if e != nil {
			log.Error(e)
			return nil, false, e
		}
		users = append(users, *_p)
	}
	if e := rows.Err(); e != nil {
		log.Error(e)
		return nil, false, e
	}
	if len(users) == 0 {
		return nil, false, sql.ErrNoRows
	}
	return users, true, nil
}

func (p *User) AssignValues(args ...dialect.Field) ([]string, []any) {
	var (
		_lens = len(args)
		_cols []string
		_vals []any
	)

	if len(args) == 0 {
		args = tbluser.WritableFields
		_lens = len(args)
		_cols = make([]string, 0, _lens)
		_vals = make([]any, 0, _lens)
		for _, arg := range args {
			switch arg {
			case tbluser.Id:
				if p.Id == 0 {
					continue
				}
				_cols = append(_cols, tbluser.Id.Quote())
				_vals = append(_vals, p.Id)
			case tbluser.Uuid:
				if p.Uuid == "" {
					continue
				}
				_cols = append(_cols, tbluser.Uuid.Quote())
				_vals = append(_vals, p.Uuid)
			case tbluser.Ctime:
				if p.Ctime.IsZero() {
					continue
				}
				_cols = append(_cols, tbluser.Ctime.Quote())
				_vals = append(_vals, p.Ctime)
			}
		}
		return _cols, _vals
	}

	_cols = make([]string, 0, _lens)
	_vals = make([]any, 0, _lens)
	for _, arg := range args {
		switch arg {
		case tbluser.Id:
			_cols = append(_cols, tbluser.Id.Quote())
			_vals = append(_vals, p.Id)
		case tbluser.Uuid:
			_cols = append(_cols, tbluser.Uuid.Quote())
			_vals = append(_vals, p.Uuid)
		case tbluser.Ctime:
			_cols = append(_cols, tbluser.Ctime.Quote())
			_vals = append(_vals, p.Ctime)
		}
	}
	return _cols, _vals
}

func (p *User) AssignKeys() (dialect.Field, any) {
	return tbluser.PrimaryKey, p.Id
}

func (p *User) AssignPrimaryKeyValues(result sql.Result) error {
	_id, e := result.LastInsertId()
	if e != nil {
		return e
	}
	p.Id = types.BigInt(_id)
	return nil
}
