// Copyright © 2023 Linbaozhong. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package handler

import (
	"bytes"
	"github.com/linbaozhong/gentity/internal/resources"
	"github.com/linbaozhong/gentity/pkg/util"
	"github.com/linbaozhong/gentity/pkg/validator"
	"go/format"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

func generateDao(tds []TempData, prefix string) error {
	for _, td := range tds {
		// 写table文件
		err := td.writeTable(filepath.Join(tablePath, "tbl"+strings.ToLower(td.StructName)))
		if err != nil {
			showError(err.Error())
			return err
		}

		// 写model文件
		err = td.writeToModel(prefix)
		if err != nil {
			showError(err)
			return err
		}

		// 写dal文件
		err = td.writeBuild(daoPath)
		if err != nil {
			showError(err.Error())
			return err
		}
	}
	return nil
}

func generateDTO(tds []TempData, prefix string) error {
	if prefix == dentityDTO {
		return nil
	}
	defer dtoFile.Close()

	var structFullName = filepath.Join(fullpath, prefix)

	astOnce.Do(func() {
		astFile, err := getAst(structFullName)
		if err != nil {
			showError(err)
			return
		}
		dtoFile, err = os.OpenFile(filepath.Join(fullpath, dentityDTO), os.O_RDWR|os.O_TRUNC|os.O_CREATE, os.ModePerm)
		if err != nil {
			showError(err)
			return
		}
		var buf bytes.Buffer
		buf.WriteString("// Code generated by gentity. DO NOT EDIT.\n\n")
		buf.WriteString("package " + astFile.Name.Name + " \n\n")
		buf.WriteString("import (\n")
		buf.WriteString("	\"bytes\" \n")
		buf.WriteString("	\"errors\" \n")
		buf.WriteString("	\"github.com/linbaozhong/gentity/pkg/gjson\" \n")
		buf.WriteString("	\"github.com/linbaozhong/gentity/pkg/log\" \n")
		buf.WriteString("	\"github.com/linbaozhong/gentity/pkg/validator\" \n")
		buf.WriteString("	\"github.com/linbaozhong/gentity/pkg/types\" \n")
		buf.WriteString("	\"github.com/linbaozhong/gentity/pkg/conv\" \n")
		buf.WriteString("	\"net/http\" \n")
		buf.WriteString(") \n\n")
		buf.WriteString("var _ = conv.Any2String(\"\")\n")
		_, err = dtoFile.Write(buf.Bytes())
		if err != nil {
			showError(err)
			return
		}
	})

	for _, td := range tds {
		// 写DTO文件
		err := writeToDTO(td, prefix)
		if err != nil {
			showError(err)
			return err
		}
	}
	return nil
}

func writeToDTO(d TempData, fileName string) error {
	funcMap := template.FuncMap{
		"lower": strings.ToLower,
		"sub": func(a, b int) int {
			return a - b
		},
		"getType":           getType,
		"getTypeValue":      getTypeValue,
		"getZeroValue":      getZeroValue,
		"getNotZeroValue":   getNotZeroValue,
		"getSqlValue":       getSqlValue,
		"getSqlType":        getSqlType,
		"getUnmarshalValue": getUnmarshalValue,
		"getTypeNil":        getTypeNil,
		"getValidFunc":      getValidFunc,
		"getValidParamFunc": getValidParamFunc,
		"getFieldString":    getFieldString,
		"contains":          util.SliceContains[string],
	}
	var fn func(ioWriter io.Writer, funcMap template.FuncMap) error
	fn = func(ioWriter io.Writer, funcMap template.FuncMap) error {
		tmpl := template.New("").Funcs(funcMap)
		_, err := tmpl.ParseFS(resources.TemplatesFS, "templates/dto_struct.tmpl")
		if err != nil {
			showError(err)
			return err
		}
		return tmpl.ExecuteTemplate(ioWriter, "dto_struct.tmpl", d)
	}

	var buf = new(bytes.Buffer)
	err := fn(buf, funcMap)
	if err != nil {
		showError(err)
		return err
	}
	formatted, _ := format.Source(buf.Bytes())
	if formatted == nil {
		_, err = dtoFile.Write(buf.Bytes())
	} else {
		_, err = dtoFile.Write(formatted)
	}
	if err != nil {
		showError(err.Error())
	}
	return err
}
func getTypeNil(t Field) any {
	switch t.Type {
	case "string", "types.String":
		return "types.NilString"
	case "int", "types.Int":
		return "types.NilInt"
	case "int8", "types.Int8":
		return "types.NilInt8"
	case "int16", "types.Int16":
		return "types.NilInt16"
	case "int32", "types.Int32":
		return "types.NilInt32"
	case "int64", "types.Int64":
		return "types.NilInt64"
	case "uint", "types.Uint":
		return "types.NilUint"
	case "uint8", "types.Uint8":
		return "types.NilUint8"
	case "uint16", "types.Uint16":
		return "types.NilUint16"
	case "uint32", "types.Uint32":
		return "types.NilUint32"
	case "uint64", "types.Uint64":
		return "types.NilUint64"
	case "float32", "types.Float32":
		return "types.NilFloat32"
	case "float64", "types.Float64":
		return "types.NilFloat64"
	case "time.Time":
		return "types.NilTime"
	case "types.Time":
		return "types.Time{}"
	case "bool", "types.Bool":
		return "types.Bool(-1)"
	default:
		return `nil`
	}
}
func getFieldString(t Field) string {
	switch t.Type {
	case "string", "types.String":
		return `p.` + t.Name
	case "types.Int", "types.Int8", "types.Int16", "types.Int32", "types.Int64",
		"types.Uint", "types.Uint8", "types.Uint16", "types.Uint32", "types.Uint64",
		"types.BigInt", "types.Money", "types.Float32", "types.Float64", "types.Time",
		"types.Bool":
		return `p.` + t.Name + ".String()"
	// case "types.String":
	// 	return `types.String(value.Str)`
	default:
		return `conv.Any2String(p.` + t.Name + `)`
	}
}

// getValidFunc
// n: 字段名
func getValidFunc(t, n string) (fo funcObj) {
	fo = funcObj{}
	pos := strings.Index(t, "~")
	if pos > 0 {
		fo.Err = t[pos+1:]
	} else {
		fo.Err = "Wrong " + n + " format"
	}
	var tag string
	if pos < 0 {
		tag = t
	} else {
		tag = t[:pos]
	}

	if fn, ok := validator.TagMap[tag]; ok {
		fo.Func = fn
		return
	}
	return
}

type funcObj struct {
	Func  string
	Param string
	Err   string
}

// getValidParamFunc
// n: 字段名
func getValidParamFunc(t, n string) (fo funcObj) {
	fo = funcObj{}
	pos := strings.Index(t, "(")
	if pos < 1 {
		return
	}
	pos1 := strings.Index(t, ")")
	if pos1 < 0 || pos1 <= pos {
		return
	}
	params := strings.Split(t[pos+1:pos1], "|")

	var tag string
	if pos < 0 {
		tag = t
	} else {
		tag = t[:pos]
	}

	pos = strings.Index(t, "~")
	if pos > 0 {
		fo.Err = t[pos+1:]
	} else {
		fo.Err = "Wrong " + n + " " + tag
	}

	if fn, ok := validator.ParamTagMap[tag]; ok {
		fo.Func = fn
		fo.Param = `"` + strings.Join(params, "\",\"") + `"`
		return
	}
	return
}
