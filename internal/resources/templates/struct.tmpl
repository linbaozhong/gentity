// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

{{- $structName := .StructName}}
{{- $structNameLower := lower .StructName}}

package {{.PackageName}}

import (
	"bytes"
	"database/sql"
	"errors"
	"{{.ModulePath}}/define/table/tbl{{ $structNameLower }}"
	"github.com/linbaozhong/gentity/pkg/ace"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
	"github.com/linbaozhong/gentity/pkg/ace/pool"
	"github.com/linbaozhong/gentity/pkg/gjson"
	"github.com/linbaozhong/gentity/pkg/log"
	{{- if .HasCustomType }}
	"github.com/linbaozhong/gentity/pkg/types"
	{{- end}}
	{{- if .HasTime }}
	"time"
	{{- end}}
)

const {{$structName}}TableName = "{{.TableName}}"

var (
	{{lower .StructName}}Pool = pool.New(ace.Context,func() any {
		obj := &{{.StructName}}{}
		obj.UUID()
		return obj
	})
)

func New{{.StructName}}() *{{.StructName}} {
	obj := {{lower .StructName}}Pool.Get().(*{{.StructName}})
	return obj
}

// MarshalJSON
func (p *{{.StructName}}) MarshalJSON() ([]byte, error) {
	var buf = bytes.NewBuffer(nil)
	buf.WriteByte('{')
	{{- range $key, $value := .Columns}}
		{{- if $value.Json.OmitEmpty}}
		if {{getNotZeroValue $value}} {
			buf.WriteString(`"{{ $value.Json.Name }}":`+types.Marshal(p.{{$value.Name}})+`,`)
		}
		{{- else}}
		buf.WriteString(`"{{ $value.Json.Name }}":`+types.Marshal(p.{{$value.Name}})+`,`)
		{{- end}}
	{{- end}}
	if l := buf.Len(); l > 1 {
		buf.Truncate(l - 1)
	}
	buf.WriteByte('}')
	return buf.Bytes(), nil
}

// UnmarshalJSON
func (p *{{.StructName}}) UnmarshalJSON(data []byte) error {
	{{- if .HasRef}}
	defer func() {
		if r := recover(); r != nil {
			log.Error(r)
			return
		}
	}()
	{{- end}}

	ok := gjson.ValidBytes(data)
	if !ok {
		return errors.New("invalid json")
	}
	result := gjson.ParseBytes(data)
	result.ForEach(func(key, value gjson.Result) bool {
		var e error
		switch key.Str {
		{{- range $key, $value := .Columns}}
			case "{{ $value.Json.Name }}":
				e = types.Unmarshal(value, &p.{{$value.Name}},{{getUnmarshalValue $value}})
		{{- end}}
		}
		if e != nil {
			log.Error(e)
			return false
		}
		return true
	})
	return nil
}

// Free
func (p *{{.StructName}}) Free() {
	if p == nil {
		return
	}

	{{lower .StructName}}Pool.Put(p)
}

// Reset
func (p *{{.StructName}}) Reset() {
	{{range $key, $value := .Columns}}p.{{$value.Name}} = {{getTypeValue $value}}
	{{end}}
}


func (p *{{.StructName}}) TableName() string {
	return {{$structName}}TableName
}

func (p *{{.StructName}}) AssignPtr(args ...dialect.Field) ([]any) {
	if len(args) == 0 {
		args = tbl{{ $structNameLower }}.ReadableFields
	}

    vals := make([]any, 0, len(args))
    for _, col := range args {
        switch col {
        {{- range $key, $value := .Columns}}
        case tbl{{$structNameLower}}.{{ $value.Name }}:
            vals = append(vals, &p.{{ $value.Name }})
        {{- end}}
        }
    }

	return vals
}

func (p *{{.StructName}}) Scan(rows *sql.Rows, args ...dialect.Field) ([]{{.StructName}}, bool, error) {
	defer rows.Close()
	{{.TableName}}s := make([]{{.StructName}}, 0)

	if len(args) == 0 {
		args = tbl{{$structNameLower}}.ReadableFields
	}

	for rows.Next() {
		p := New{{.StructName}}()
		vals := p.AssignPtr(args...)
		err := rows.Scan(vals...)
		if err != nil {
			log.Error(err)
			return nil, false, err
		}
		{{.TableName}}s = append({{.TableName}}s, *p)
	}
	if err := rows.Err(); err != nil {
		log.Error(err)
		return nil, false, err
	}
	if len({{.TableName}}s) == 0 {
		return nil, false, sql.ErrNoRows
	}
	return {{.TableName}}s, true, nil
}

func (p *{{.StructName}})AssignValues(args ...dialect.Field) ([]string, []any) {
	var (
		lens = len(args)
		cols []string
		vals []any
	)

	if len(args) == 0 {
		args = tbl{{$structNameLower}}.WritableFields
		lens = len(args)
		cols = make([]string, 0, lens)
		vals = make([]any, 0, lens)
		for _, arg := range args {
			switch arg {
			{{- range $key, $value := .Columns}}
				{{- if ne (getType $value) "any"}}
			case tbl{{$structNameLower}}.{{ $value.Name }}:
				if p.{{ $value.Name }}{{getZeroValue $value}} {
					continue
				}
				cols = append(cols, tbl{{$structNameLower}}.{{ $value.Name }}.Quote())
				vals = append(vals, p.{{ $value.Name }})
				{{- end}}
			{{- end}}
			}
		}
		return cols, vals
	}

	cols = make([]string, 0, lens)
	vals = make([]any, 0, lens)
	for _, arg := range args {
		switch arg {
		{{- range $key, $value := .Columns}}
			{{- if ne (getType $value) "any"}}
		case tbl{{$structNameLower}}.{{ $value.Name }}:
			cols = append(cols, tbl{{$structNameLower}}.{{ $value.Name }}.Quote())
			vals = append(vals, p.{{ $value.Name }})
			{{- end}}
		{{- end}}
		}
	}
	return cols, vals
}

//
func (p *{{.StructName}}) AssignKeys() (dialect.Field, any) {
	return tbl{{$structNameLower}}.PrimaryKey,p.{{.PrimaryKey.Name}}
}


//
func (p *{{.StructName}}) AssignPrimaryKeyValues(result sql.Result) error {
    {{- if eq (.PrimaryKey.Rw) "<-" }}
	id, err := result.LastInsertId()
	if err != nil {
        return err
    }
    p.{{.PrimaryKey.Name}} = {{.PrimaryKey.Type}}(id)
    {{- end}}
    return nil
}
