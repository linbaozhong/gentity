// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

{{- $structName := .StructName}}
{{- $structNameLower := lower .StructName}}

package {{.PackageName}}

import (
	"bytes"
	"database/sql"
	"errors"
	"{{.ModulePath}}/define/table/tbl{{ $structNameLower }}"
	"github.com/linbaozhong/gentity/pkg/app"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
	"github.com/linbaozhong/gentity/pkg/ace/pool"
	"github.com/linbaozhong/gentity/pkg/gjson"
	"github.com/linbaozhong/gentity/pkg/log"
	{{- if .HasCustomType }}
	"github.com/linbaozhong/gentity/pkg/types"
	{{- end}}
	{{- if .HasTime }}
	"time"
	{{- end}}
)

const {{$structName}}TableName = "{{.TableName}}"

var (
	{{$structNameLower}}Pool = pool.New(app.Context,func() any {
		_obj := &{{.StructName}}{}
		return _obj
	})
)

func New{{.StructName}}() *{{.StructName}} {
	_obj := {{$structNameLower}}Pool.Get().(*{{.StructName}})
	return _obj
}

// MarshalJSON
func (p *{{.StructName}}) MarshalJSON() ([]byte, error) {
	var (
		_buf = bytes.NewBuffer((make([]byte, 0, {{len .Columns}} * 50)))
		_comma bool
	)
	_buf.WriteByte('{')

	writeField := func(key string, value string) {
		if _comma {
			_buf.WriteByte(',')
		}
		_buf.WriteByte('"')
		_buf.WriteString(key)
		_buf.WriteString(`":`)
		_buf.WriteString(value)
		_comma = true
	}


	{{- range $key, $value := .Columns}}
		{{- if $value.Json.OmitEmpty}}
		if {{getNotZeroValue $value}} {
			writeField("{{ $value.Json.Name }}",types.Marshal(p.{{$value.Name}}))
		}
		{{- else}}
			writeField("{{ $value.Json.Name }}",types.Marshal(p.{{$value.Name}}))
		{{- end}}
	{{- end}}
	_buf.WriteByte('}')
	return _buf.Bytes(), nil
}

// UnmarshalJSON
func (p *{{.StructName}}) UnmarshalJSON(data []byte) error {
	{{- if .HasRef}}
	defer func() {
		if r := recover(); r != nil {
			log.Error(r)
			return
		}
	}()
	{{- end}}

	if !gjson.ValidBytes(data) {
		return errors.New("invalid json")
	}
	_result := gjson.ParseBytes(data)
	_result.ForEach(func(key, value gjson.Result) bool {
		var e error
		switch key.Str {
		{{- range $key, $value := .Columns}}
			case "{{ $value.Json.Name }}":
				{{getUnmarshalJSON $value}}
		{{- end}}
		}
		if e != nil {
			log.Error(e)
			return false
		}
		return true
	})
	return nil
}

// Free
func (p *{{.StructName}}) Free() {
	if p == nil {
		return
	}

	{{$structNameLower}}Pool.Put(p)
}

// Reset
func (p *{{.StructName}}) Reset() {
	{{range $key, $value := .Columns}}p.{{$value.Name}} = {{getTypeValue $value}}
	{{end}}
}


func (p *{{.StructName}}) TableName() string {
	return {{$structName}}TableName
}

// 定义一个映射表，将字段与对应的指针获取函数关联
var {{$structNameLower}}FieldToPtrFunc = map[dialect.Field]func(*{{.StructName}}) any {
{{- range $key, $value := .Columns}}
	tbl{{$structNameLower}}.{{ $value.Name }}: func(p *{{$structName}}) any { return &p.{{ $value.Name }} },
{{- end}}
}

// AssignPtr 根据传入的字段参数，返回对应字段的指针切片。
// 如果未传入任何字段参数，则默认使用 ReadableFields 中的字段。
// 参数 args 为可变参数，代表需要获取指针的字段。
// 返回值为一个包含对应字段指针的切片。
func (p *{{.StructName}}) AssignPtr(args ...dialect.Field) ([]any) {
	if len(args) == 0 {
		args = tbl{{ $structNameLower }}.ReadableFields
	}

    _vals := make([]any, 0, len(args))
    for _, col := range args {
		if ptrFunc, ok := {{$structNameLower}}FieldToPtrFunc[col]; ok {
			_vals = append(_vals, ptrFunc(p))
		}
    }

	return _vals
}

func (p *{{.StructName}}) Scan(rows *sql.Rows, args ...dialect.Field) ([]*{{.StructName}}, bool, error) {
	defer rows.Close()
	{{.TableName}}s := make([]*{{.StructName}}, 0)

	if len(args) == 0 {
		args = tbl{{$structNameLower}}.ReadableFields
	}

	for rows.Next() {
		_p := New{{.StructName}}()
		_vals := _p.AssignPtr(args...)
		e := rows.Scan(_vals...)
		if e != nil {
			log.Error(e)
			return nil, false, e
		}
		{{.TableName}}s = append({{.TableName}}s, _p)
	}
	if e := rows.Err(); e != nil {
		log.Error(e)
		return nil, false, e
	}
	return {{.TableName}}s, len({{.TableName}}s) > 0, nil
}

// RawAssignValues 向数据库写入数据前，为表列赋值。多用于批量插入和更新
// 如果 args 为空，则赋值所有可写字段
// 如果 args 不为空，则只赋值 args 中的字段
func (p *{{.StructName}}) RawAssignValues(args ...dialect.Field) ([]string, []any) {
	if len(args) == 0 {
		args = tbl{{$structNameLower}}.WritableFields
	}
	return p.AssignValues(args...)
}


// 定义字段到值检查和获取函数的映射
var {{$structNameLower}}FieldToValueFunc = map[dialect.Field]func(*{{$structName}}) (string, any, bool) {
{{- range $key, $value := .Columns}}
	{{- if ne (getType $value) "any"}}
	tbl{{$structNameLower}}.{{ $value.Name }}: func(p *{{$structName}}) (string, any, bool) {
		return tbl{{$structNameLower}}.{{ $value.Name }}.Quote(), p.{{ $value.Name }}, p.{{ $value.Name }}{{getZeroValue $value}}
	},
	{{- end}}
{{- end}}
}

// AssignValues 向数据库写入数据前，为表列赋值。
// 如果 args 为空，则将非零值赋与可写字段
// 如果 args 不为空，则只赋值 args 中的字段
func (p *{{.StructName}})AssignValues(args ...dialect.Field) ([]string, []any) {
	var (
		_lens = len(args)
		_cols []string
		_vals []any
	)
	if _lens > 0 {
		_cols = make([]string, 0, _lens)
		_vals = make([]any, 0, _lens)
		for _, arg := range args {
			if valueFunc, exists := {{$structNameLower}}FieldToValueFunc[arg]; exists {
				colName, value, _ := valueFunc(p)
				_cols = append(_cols, colName)
				_vals = append(_vals, value)
			}
		}
		return _cols, _vals
	}

	args = tbl{{$structNameLower}}.WritableFields
	_lens = len(args)
	_cols = make([]string, 0, _lens)
	_vals = make([]any, 0, _lens)
	for _, arg := range args {
		if valueFunc, exists := {{$structNameLower}}FieldToValueFunc[arg]; exists {
			colName, value, valid := valueFunc(p)
			if !valid {
				_cols = append(_cols, colName)
				_vals = append(_vals, value)
			}
		}
	}
	return _cols, _vals
}

//
func (p *{{.StructName}}) AssignKeys() (dialect.Field, any) {
	return tbl{{$structNameLower}}.PrimaryKey,p.{{.PrimaryKey.Name}}
}


//
func (p *{{.StructName}}) AssignPrimaryKeyValues(result sql.Result) error {
    {{- if eq (.PrimaryKey.Rw) "<-" }}
	_id, e := result.LastInsertId()
	if e != nil {
        return e
    }
    p.{{.PrimaryKey.Name}} = {{.PrimaryKey.Type}}(_id)
    {{- end}}
    return nil
}
