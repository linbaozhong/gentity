// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

{{- $tablename := .TableName}}
{{- $structName := .StructName}}
{{- $structNameLower := lower .StructName}}
{{- $keys := .Keys}}
package {{.PackageName}}

import (
	"database/sql"
	"sync"
	{{- if .HasTime }}
	"time"
	{{- end}}
	"{{.ModulePath}}/define/table/{{$structNameLower}}tbl"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
)

const {{$structName}}TableName = "{{.TableName}}"

var (
	{{lower .StructName}}Pool = sync.Pool{
		New: func() interface{} {
			return &{{.StructName}}{}
		},
	}
)

func New{{.StructName}}() *{{.StructName}} {
	return {{lower .StructName}}Pool.Get().(*{{.StructName}})
}

//Free
func (p *{{.StructName}}) Free() {
	if p == nil {
		return
	}
	{{range $key, $value := .Columns}}p.{{index $value 0}} = {{getTypeValue $value}}
	{{end}}
	{{lower .StructName}}Pool.Put(p)
}


func (p *{{.StructName}}) TableName() string {
	return {{$structName}}TableName
}

func (p *{{.StructName}}) Scan(rows *sql.Rows, args ...dialect.Field) ([]*{{.StructName}}, bool, error) {
	defer rows.Close()
	{{.TableName}}s := make([]*{{.StructName}}, 0)

	if len(args) == 0 {
		args = {{$structNameLower}}tbl.ReadableFields
	}

	for rows.Next() {
		p := New{{.StructName}}()
		vals := make([]any, 0, len(args))
		for _, col := range args {
			switch col {
			{{- range $key, $value := .Columns}}
			case {{$structNameLower}}tbl.{{ index $value 0 }}:
				vals = append(vals, &p.{{ index $value 0 }})
			{{- end}}
			}
		}
		err := rows.Scan(vals...)
		if err != nil {
			return nil, false, err
		}
		{{.TableName}}s = append({{.TableName}}s, p)
	}
	if err := rows.Err(); err != nil {
		return nil, false, err
	}
	if len({{.TableName}}s) == 0 {
		return nil, false, sql.ErrNoRows
	}
	return {{.TableName}}s, true, nil
}

func (p *{{.StructName}})AssignValues(args ...dialect.Field) ([]string, []any) {
	var (
		lens = len(args)
		cols []string
		vals []any
	)

	if len(args) == 0 {
		args = {{$structNameLower}}tbl.WritableFields
		lens = len(args)
		cols = make([]string, 0, lens)
		vals = make([]any, 0, lens)
		for _, arg := range args {
			switch arg {
			{{- range $key, $value := .Columns}}
			case {{$structNameLower}}tbl.{{ index $value 0 }}:
				if p.{{ index $value 0 }}{{getZeroValue $value}} {
					continue
				}
				cols = append(cols, {{$structNameLower}}tbl.{{ index $value 0 }}.Quote())
				vals = append(vals, p.{{ index $value 0 }})
			{{- end}}
			}
		}
		return cols, vals
	}

	cols = make([]string, 0, lens)
	vals = make([]any, 0, lens)
	for _, arg := range args {
		switch arg {
		{{- range $key, $value := .Columns}}
		case {{$structNameLower}}tbl.{{ index $value 0 }}:
			cols = append(cols, {{$structNameLower}}tbl.{{ index $value 0 }}.Quote())
			vals = append(vals, p.{{ index $value 0 }})
		{{- end}}
		}
	}
	return cols, vals
}

//
func (p *{{.StructName}}) AssignKeys() ([]dialect.Field, []any) {
	return {{$structNameLower}}tbl.PrimaryKeys, []any{
	{{- range $key,$value := .Keys}}
		p.{{$value}},
	{{- end}}
	}
}

