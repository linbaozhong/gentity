// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

{{- $tablename := .TableName}}
{{- $structName := .StructName}}
{{- $package := .PackageName}}
{{- $structNameLower := lower .StructName}}

package dao  //{{$structNameLower}}

import (
{{- if .HasCache}}
	"time"
	"encoding/json"
	"golang.org/x/sync/singleflight"
	"github.com/linbaozhong/gentity/pkg/cachego"
	"github.com/linbaozhong/gentity/pkg/conv"
{{- end}}
	"context"
	"database/sql"
	"{{.ModulePath}}/{{$package}}"
	"{{.ModulePath}}/define/table/tbl{{$structNameLower}}"
{{- if ne .RelationX.Name ""}}
	"{{.ModulePath}}/define/table/tbl{{lower .RelationX.Type}}"
{{- end}}
	"github.com/linbaozhong/gentity/pkg/ace"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
	"github.com/linbaozhong/gentity/pkg/ace/pool"
	"github.com/linbaozhong/gentity/pkg/app"
	"github.com/linbaozhong/gentity/pkg/log"
	"github.com/linbaozhong/gentity/pkg/types"
)

type {{$structNameLower}} struct {
	pool.Model
	db    ace.Executer
	toSql bool
{{- if .HasCache}}
	cache cachego.Cache
	sg singleflight.Group
{{- end}}
}

var(
	{{$structNameLower}}Pool = pool.New(app.Context, func() any {
		_obj := &{{$structNameLower}}{}
		_obj.db = ace.GetExec()
		return _obj
	})
)

// New 实例化{{$structNameLower}}
// exec: 执行器，用于执行sql语句，如：db,tx
// 如果不传入，则使用默认的db
func {{$structName}}(exec ...ace.Executer) *{{$structNameLower}} {
	_obj := {{$structNameLower}}Pool.Get().(*{{$structNameLower}})
	_obj.UUID()
	_obj.db = ace.GetExec(exec...)
{{- if .HasCache}}
	_obj.cache = _obj.db.Cache({{$package}}.{{$structName}}TableName)
{{- end}}
	return _obj
}

// Free 释放对象
func (p *{{$structNameLower}}) Free() {
	if p == nil {
		return
	}

	{{$structNameLower}}Pool.Put(p)
}

// Reset 重置对象
func (p *{{$structNameLower}}) Reset() {
	p.toSql = false
	p.db = nil
}

// ToSql 仅打印SQL语句，不执行
func (p *{{$structNameLower}}) ToSql() *{{$structNameLower}} {
	p.toSql = true
	return p
}

// Insert 返回 LastInsertId
func (p *{{$structNameLower}}) Insert(ctx context.Context, sets ...dialect.Setter) (int64, error) {
	defer p.Free()
	if len(sets) == 0 {
		return 0, dialect.ErrSetterEmpty
	}
	_result, e := ace.Table({{$package}}.{{$structName}}TableName).
		Set(sets...).
		ToSql(p.toSql).
		Create(p.db).
		Exec(ctx)
	if e != nil {
		log.Error(e)
		return 0, e
	}
	return _result.LastInsertId()
}

// InsertOne
// cols: 要插入的列名
func (p *{{$structNameLower}}) InsertOne(ctx context.Context, bean *{{$package}}.{{$structName}}, cols ...dialect.Field) (bool, error) {
	defer p.Free()
	_result, e := ace.Table({{$package}}.{{$structName}}TableName).
		Cols(cols...).
		ToSql(p.toSql).
		Create(p.db).
		Struct(ctx, bean)
	if e != nil {
		log.Error(e)
		return false, e
	}

    bean.AssignPrimaryKeyValues(_result)

	_n, e := _result.RowsAffected()
	return _n > 0, e
}

// InsertBatch 批量插入,返回 RowsAffected。禁止在事务中使用
// cols: 要插入的列名，如果为空，则插入结构体字段对应所有列
func (p *{{$structNameLower}}) InsertBatch(ctx context.Context, beans []*{{$package}}.{{$structName}}, cols ...dialect.Field) (int64, error) {
	defer p.Free()
	_lens := len(beans)
	if _lens == 0 {
		return 0, dialect.ErrBeanEmpty
	}
	_args := make([]dialect.Modeler, 0, _lens)
	for _, _bean := range beans {
		_args = append(_args, _bean)
	}
	_result, e := ace.Table({{$package}}.{{$structName}}TableName).
		Cols(cols...).
		ToSql(p.toSql).
		Create(p.db).
		BatchStruct(ctx, _args...)
	if e != nil {
		log.Error(e)
		return 0, e
	}

	return _result.RowsAffected()
}

// Update
func (p *{{$structNameLower}}) Update(ctx context.Context, sets []dialect.Setter, cond ...dialect.Condition) (bool, error) {
	defer p.Free()
	if len(sets) == 0 {
		return false, dialect.ErrSetterEmpty
	}
	_result, e := ace.Table({{$package}}.{{$structName}}TableName).
		Where(cond...).
		Set(sets...).
		ToSql(p.toSql).
		Update(p.db).
		Exec(ctx)
	if e != nil {
		log.Error(e)
		return false, e
	}
	_n, e := _result.RowsAffected()
	return _n >= 0, e
}

// UpdateById
func (p *{{$structNameLower}}) UpdateById(ctx context.Context,{{.PrimaryKey.Col}} {{.PrimaryKey.Type}}, sets ...dialect.Setter) (bool, error) {
    return p.Update(ctx,
        sets,
       	tbl{{$structNameLower}}.PrimaryKey.Eq({{.PrimaryKey.Col}}),
    )
}

// UpdateOne
// cols: 要插入的列名
func (p *{{$structNameLower}}) UpdateOne(ctx context.Context, bean *{{$package}}.{{$structName}}, cols ...dialect.Field) (bool, error) {
	defer p.Free()
	_result, e := ace.Table({{$package}}.{{$structName}}TableName).
		Cols(cols...).
		ToSql(p.toSql).
		Update(p.db).
		Struct(ctx, bean)
	if e != nil {
		log.Error(e)
		return false, e
	}

	_n, e := _result.RowsAffected()
	return _n >= 0, e
}

// UpdateBatch 批量更新,禁止在事务中使用
// cols: 要更新的列名，如果为空，则更新结构体所有字段对应列，包含零值字段
func (p *{{$structNameLower}}) UpdateBatch(ctx context.Context, beans []*{{$package}}.{{$structName}}, cols ...dialect.Field) (bool, error) {
	defer p.Free()
	_lens := len(beans)
	if _lens == 0 {
		return false, dialect.ErrBeanEmpty
	}
	_args := make([]dialect.Modeler, 0, _lens)
	for _, _bean := range beans {
		_args = append(_args, _bean)
	}
	_result, e := ace.Table({{$package}}.{{$structName}}TableName).
		Cols(cols...).
		ToSql(p.toSql).
		Update(p.db).
		BatchStruct(ctx, _args...)
	if e != nil {
		log.Error(e)
		return false, e
	}
	_n, e := _result.RowsAffected()
	return _n >= 0, e
}

// Delete
func (p *{{$structNameLower}}) Delete(ctx context.Context, cond ...dialect.Condition) (bool, error) {
	defer p.Free()
	_result, e := ace.Table({{$package}}.{{$structName}}TableName).
		Where(cond...).
		ToSql(p.toSql).
		Delete(p.db).
		Exec(ctx)
	if e != nil {
		log.Error(e)
		return false, e
	}
	_n, e := _result.RowsAffected()
	return _n >= 0, e
}

// DeleteById
func (p *{{$structNameLower}}) DeleteById(ctx context.Context, {{.PrimaryKey.Col}} {{.PrimaryKey.Type}}) (bool, error) {
	return p.Delete(ctx,
		tbl{{$structNameLower}}.PrimaryKey.Eq({{.PrimaryKey.Col}}),
		)
}

// Get 查询第一个符合条件的记录
//  s: 选择器，用于构建sql语句
// 返回值:
//  1. *{{$package}}.{{$structName}}: 第一个符合条件的记录
//  2. bool: 是否存在记录
//  3. error: 错误信息
// 注意:
//  1. 如果没有指定表名，则默认使用{{$package}}.{{$structName}}TableName
//  2. 如果没有指定查询列，则默认使用tbl{{$structNameLower}}.ReadableFields
//  3. 如果没有指定排序方式，则默认使用dialect.OrderAsc
//  4. 如果没有指定条件，则默认查询所有记录
//  5. 如果查询出错，则返回nil, false, error
//  6. 如果没有查询到记录，则返回nil, false, nil
//  7. 如果查询到记录，则返回记录, true, nil
//  8. 如果查询到多条记录，则返回第一条记录, true, nil
func (p *{{$structNameLower}}) Get(ctx context.Context, s ace.SelectBuilder) (*{{$package}}.{{$structName}}, bool, error) {
	defer p.Free()
	if len(s.GetTableName()) == 0 {
		s.Table({{$package}}.{{$structName}}TableName)
	}
	_cols := s.GetCols()
	if len(_cols) == 0 {
		_cols = tbl{{$structNameLower}}.ReadableFields
		s.Cols(_cols...)
	}
	_row, e := s.
		ToSql(p.toSql).
		Select(p.db).
		QueryRow(ctx)
	if e!= nil {
		log.Error(e)
		return nil, false, e
	}
	_obj := {{$package}}.New{{$structName}}()
	e = _row.Scan(_obj.AssignPtr(_cols...)...)
	switch e {
	case nil:
		return _obj, true, nil
	case sql.ErrNoRows:
		return _obj, false, nil
	default:
		log.Error(e)
		return _obj, false, e
	}
}

// GetByID 按主键读取一个{{.TableName}}对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *{{$structNameLower}}) GetByID(ctx context.Context,{{.PrimaryKey.Col}} {{.PrimaryKey.Type}}, cols ...dialect.Field) (*{{$package}}.{{$structName}}, bool, error) {
	defer p.Free()
{{- if .HasCache}}
	_obj,has,e:=p.getCache(ctx, {{.PrimaryKey.Col}})
	if has{
		return _obj,has,nil
	}

	_v, e, _ := p.sg.Do(conv.Any2String({{.PrimaryKey.Col}}), func() (any, error) {
		//_obj, has, e = p.Get4Cols(ctx, cols, []dialect.Condition{tbl{{$structNameLower}}.PrimaryKey.Eq({{.PrimaryKey.Col}})})
		_obj, has, e = p.Get(ctx, ace.Table({{$package}}.{{$structName}}TableName).Where(tbl{{$structNameLower}}.PrimaryKey.Eq({{.PrimaryKey.Col}})).Cols(cols...))
		if has {
			e = p.setCache(ctx, _obj)
		}
		return _obj, e
	})
	if _v != nil {
		return _v.(*{{$package}}.{{$structName}}), true, e
	}

	return nil,false,e
{{- else}}
	return p.Get(ctx, ace.Table({{$package}}.{{$structName}}TableName).Where(tbl{{$structNameLower}}.PrimaryKey.Eq({{.PrimaryKey.Col}})).Cols(cols...))
{{- end}}
}

// Cell 查询第一个符合条件的记录的第一个列
//  s: 选择器，用于构建sql语句
// 返回值:
//  1. any: 第一个符合条件的记录的第一个列
//  2. bool: 是否存在记录
//  3. error: 错误信息
// 注意:
//  1. 如果没有指定表名，则默认使用{{$package}}.{{$structName}}TableName
//  2. 如果没有指定查询列，则默认使用tbl{{$structNameLower}}.PrimaryKey
func (p *{{$structNameLower}}) Cell(ctx context.Context,s ace.SelectBuilder) (any, bool, error) {
	defer p.Free()
	if len(s.GetTableName()) == 0 {
		s.Table({{$package}}.{{$structName}}TableName)
	}

	if len(s.GetCols()) == 0 {
		s.Cols(tbl{{$structNameLower}}.PrimaryKey)
	}
	_row, e := s.
		ToSql(p.toSql).
		Select(p.db).
		QueryRow(ctx)
	if e!= nil {
		log.Error(e)
		return nil, false, e
	}
	var _v any
	e = _row.Scan(&_v)
	switch e {
	case nil:
		return _v, true, nil
	case sql.ErrNoRows:
		return _v, false, nil
	default:
		log.Error(e)
		return _v, false, e
	}
}

// List 查询所有符合条件的记录
func (p *{{$structNameLower}}) List(ctx context.Context, s ace.SelectBuilder) ([]*{{$package}}.{{$structName}}, bool, error) {
	defer p.Free()
	if len(s.GetTableName()) == 0{
		s.Table({{$package}}.{{$structName}}TableName)
	}

	_cols := s.GetCols()
	if len(_cols) == 0 {
		_cols = tbl{{$structNameLower}}.ReadableFields
		s.Cols(_cols...)
	}

	_rows, e := s.
		ToSql(p.toSql).
		Select(p.db).
		Query(ctx)
	if e != nil {
		log.Error(e)
		return nil, false, e
	}
	defer _rows.Close()

	_obj := {{$package}}.New{{$structName}}()
	_objs, has, e := _obj.Scan(_rows,_cols...)
	if has {
		return _objs, true, nil
	}
	if e == nil || e == sql.ErrNoRows {
		return _objs, false, nil
	}
	log.Error(e)
	return _objs, false, e
}


// Count
func (p *{{$structNameLower}}) Count(ctx context.Context, cond ...dialect.Condition) (int64, error) {
	defer p.Free()
	return ace.Table({{$package}}.{{$structName}}TableName).
		ToSql(p.toSql).
		Select(p.db).
		Count(ctx, cond...)
}

// Sum
func (p *{{$structNameLower}}) Sum(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (map[string]any, error) {
	defer p.Free()
	return ace.Table({{$package}}.{{$structName}}TableName).
		ToSql(p.toSql).
		Select(p.db).
		Sum(ctx, cols, cond...)
}

// Exists
func (p *{{$structNameLower}}) Exists(ctx context.Context, cond ...dialect.Condition) (bool, error) {
	defer p.Free()
	_c := ace.Table({{$package}}.{{$structName}}TableName).Cols(tbl{{$structNameLower}}.PrimaryKey).Where(cond...)
	_row, e := _c.
		ToSql(p.toSql).
		Select(p.db).
		QueryRow(ctx)
	if e != nil {
		log.Error(e)
		return false, e
	}

	var {{ .PrimaryKey.Col }} {{.PrimaryKey.Type}}
	e = _row.Scan(&{{.PrimaryKey.Col}})
	switch e {
	case nil:
		return true, nil
    case sql.ErrNoRows:
        return false, nil
    default:
        return false, e
    }
}

{{- if .HasCache}}
// onUpdate
func (p *{{$structNameLower}}) onUpdate(ctx context.Context, ids ...{{.PrimaryKey.Type}}) error {
	defer p.Free()
	for _, _id := range ids {
		if e := p.cache.Delete(ctx, GetIdHashKey(_id)); e != nil {
			log.Error(e)
			return e
		}
	}

	return p.cache.PrefixDelete(ctx, "s:")
}

// getCache
func (p *{{$structNameLower}}) getCache(ctx context.Context, {{.PrimaryKey.Col}} {{.PrimaryKey.Type}}) (*{{$package}}.{{$structName}}, bool, error) {
	_s,e := p.cache.Fetch(ctx, GetIdHashKey({{.PrimaryKey.Col}}))
	if e != nil {
		log.Error(e)
		return nil, false, e
	}
	if len(_s)==0 {
		return nil, false, nil
	}
	_obj := {{$package}}.New{{$structName}}()
	e = json.Unmarshal(_s, _obj)
	if e != nil {
		log.Error(e)
		return nil, false, e
	}
	return _obj, true,nil
}

// setCache
func (p *{{$structNameLower}}) setCache(ctx context.Context, obj *{{$package}}.{{$structName}}) error {
	_s,e := json.Marshal(obj)
	if e != nil {
		log.Error(e)
		return e
	}
	return p.cache.Save(ctx, GetIdHashKey(obj.{{.PrimaryKey.Name}}), string(_s), {{.CacheData}})
}


// 生成综合条件cond缓存key
func GetCondHashKey(key any) string {
	return cachego.GetHashKey("c:", key)
}

// 生成id缓存key
func GetIdHashKey(key any) string {
	return cachego.GetHashKey("i:", key)
}

// 生成ids缓存key
func GetIdsHashKey(key any) string {
	return cachego.GetHashKey("s:", key)
}

{{end}}

{{- if ne .RelationX.Name ""}}

//////////////


// GetX 先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *{{$structNameLower}}) GetX(ctx context.Context, s ace.SelectBuilder) (*{{$package}}.{{$structName}}, bool, error) {
	defer p.Free()
	if len(s.GetTableName()) == 0 {
		s.Table({{$package}}.{{$structName}}TableName)
	}
	_cols := s.GetCols()
	if len(_cols) == 0 {
		_cols = tbl{{$structNameLower}}.ReadableFields
		s.Cols(_cols...)
	}
	_row, e := s.
		ToSql(p.toSql).
		Select(p.db).
		QueryRow(ctx)
	if e != nil {
		log.Error(e)
		return nil, false, e
	}

	_obj := {{$package}}.New{{$structName}}()

	e = _row.Scan(_obj.AssignPtr(cols...)...)
	switch e {
	case nil:
		rs := p.edges(ctx,[]any{_obj.{{.RelationX.Field}}})
		if len(rs) > 0{
{{- if eq .RelationX.Kind "slice"}}
			_obj.{{.RelationX.Name}} = rs[_obj.{{.RelationX.Field}}]
{{- else if eq .RelationX.Kind "ptr"}}
			tmp := rs[_obj.{{.RelationX.Field}}][0]
			_obj.{{.RelationX.Name}} = &tmp
{{- else}}
			_obj.{{.RelationX.Name}} = rs[_obj.{{.RelationX.Field}}][0]
{{- end}}
		}
		return _obj, true, nil
	case sql.ErrNoRows:
		return _obj, false, nil
	default:
		log.Error(e)
		return _obj, false, e
	}
}

// edges
func (p *{{$structNameLower}}) edges(ctx context.Context,ids []any) map[any][]{{$package}}.{{.RelationX.Type}} {
	defer p.Free()
	rsMap := make(map[any][]{{$package}}.{{.RelationX.Type}}, len(ids))
	rs, has, _ := {{.RelationX.Type}}(p.db).List(ctx, ace.Where(tbl{{lower (.RelationX.Type)}}.{{.RelationX.Foreign}}.In(ids...)))
	if !has {
		return rsMap
	}
	for _, r := range rs {
		rsMap[r.{{.RelationX.Foreign}}] = append(rsMap[r.{{.RelationX.Foreign}}], r)
	}
	return rsMap
}

// ListX 分页获取{{.TableName}} slice对象，先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *{{$structNameLower}}) ListX(ctx context.Context, s ace.SelectBuilder) ([]*{{$package}}.{{$structName}}, bool, error) {
	defer p.Free()
	if len(s.GetTableName()) == 0{
		s.Table({{$package}}.{{$structName}}TableName)
	}

	_cols := s.GetCols()
	if len(_cols) == 0 {
		_cols = tbl{{$structNameLower}}.ReadableFields
		s.Cols(_cols...)
	}

	_rows, e := s.
		ToSql(p.toSql).
		Select(p.db).
		Query(ctx)
	if e != nil {
		log.Error(e)
		return nil, false, e
	}
	defer rows.Close()

	obj := {{$package}}.New{{$structName}}()

	_objs, has, e := obj.Scan(rows, cols...)
	if has {
		l := len(_objs)
		idsMap := make(map[any]struct{}, l)
		ids := make([]any, 0, l)
		for i := 0; i < l; i++ {
			if _, ok := idsMap[_objs[i].{{.RelationX.Field}}]; ok {
				continue
			}
			idsMap[_objs[i].{{.RelationX.Field}}] = struct{}{}
			ids = append(ids, _objs[i].{{.RelationX.Field}})
		}
		if len(ids) == 0 {
			return _objs, true, nil
		}
		rs := p.edges(ctx, ids)
		if len(rs) > 0 {
			for i := 0; i < l; i++ {
			{{- if eq .RelationX.Kind "slice"}}
				_objs[i].{{.RelationX.Name}} = rs[_objs[i].{{.RelationX.Field}}]
			{{- else if eq .RelationX.Kind "ptr"}}
				tmp := rs[_objs[i].{{.RelationX.Field}}][0]
				_objs[i].{{.RelationX.Name}} = &tmp
			{{- else}}
				_objs[i].{{.RelationX.Name}} = rs[_objs[i].{{.RelationX.Field}}][0]
			{{- end}}
			}
		}
		return _objs, true, nil
	}
	if e == nil || e == sql.ErrNoRows {
		return _objs, false, nil
	}
	log.Error(e)
	return _objs, false, e
}

// GetByID 按主键读取一个{{.TableName}}对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *{{$structNameLower}}) GetByIDX(ctx context.Context, id types.BigInt, cols ...dialect.Field) (*{{$package}}.{{$structName}}, bool, error) {
	return p.GetX(ctx, ace.Table({{$package}}.{{$structName}}TableName).Where(tbl{{$structNameLower}}.PrimaryKey.Eq({{.PrimaryKey.Col}})).Cols(cols...))
}

{{- end}}