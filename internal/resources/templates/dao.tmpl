// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

{{- $tablename := .TableName}}
{{- $structName := .StructName}}
{{- $tbl := lower .StructName}}
{{- $package := .PackageName}}
{{- $structNameLower := lower .StructName}}

package dao

import (
	{{- if .HasCache}}
	"time"
	"encoding/json"
	"golang.org/x/sync/singleflight"
	"github.com/linbaozhong/gentity/pkg/cachego"
	"github.com/linbaozhong/gentity/pkg/conv"
	{{- end}}
	"context"
	"database/sql"
	"{{.ModulePath}}/{{$package}}"
	"{{.ModulePath}}/define/table/tbl{{$tbl}}"
{{- if ne .RelationX.Name ""}}
	"{{.ModulePath}}/define/table/tbl{{lower .RelationX.Type}}"
{{- end}}
	"github.com/linbaozhong/gentity/pkg/ace"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
	"github.com/linbaozhong/gentity/pkg/types"
)

type {{$tablename}}er interface {
	dialect.Daoer
	ace.Cruder
	// InsertOne 插入一条数据，返回 LastInsertId
	// cols: 要插入的列名
	InsertOne(ctx context.Context, bean *{{$package}}.{{$structName}}, cols ...dialect.Field) (bool, error)
	// InsertBatch 批量插入多条数据,返回 RowsAffected
	// cols: 要插入的列名
	InsertBatch(ctx context.Context, beans []*{{$package}}.{{$structName}}, cols ...dialect.Field) (int64, error)
    // UpdateById 按主键更新一条数据
	UpdateById(ctx context.Context, {{.PrimaryKey.Col}} {{.PrimaryKey.Type}}, sets ...dialect.Setter) (bool, error)
	// UpdateBatch 批量更新多条数据
	// cols: 要更新的列名
	UpdateBatch(ctx context.Context, beans []*{{$package}}.{{$structName}}, cols ...dialect.Field) (bool, error)
	// DeleteById 按主键删除一条数据
    DeleteById(ctx context.Context,{{.PrimaryKey.Col}} {{.PrimaryKey.Type}}) (bool, error)
	// Find4Cols 分页查询指定列，返回一个slice
	Find4Cols(ctx context.Context, pageIndex, pageSize uint, cols []dialect.Field, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error)
	// Find 分页查询，返回一个slice
	Find(ctx context.Context, pageIndex, pageSize uint, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error)
	// Get4Cols 读取一个对象的指定列
	Get4Cols(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error)
	// GetByID 按主键查询，返回一个对象
	GetByID(ctx context.Context,{{.PrimaryKey.Col}} {{.PrimaryKey.Type}}, cols ...dialect.Field) (*{{$package}}.{{$structName}}, bool, error)
	// Get 按条件读取一个对象
	Get(ctx context.Context, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error)
{{- if ne .RelationX.Name ""}}
	// Find4Cols 分页查询指定列，返回一个slice
	Find4ColsX(ctx context.Context, pageIndex, pageSize uint, cols []dialect.Field, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error)
	// Find 分页查询，返回一个slice
	FindX(ctx context.Context, pageIndex, pageSize uint, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error)
	// Get4Cols 读取一个对象的指定列
	Get4ColsX(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error)
	// GetByID 按主键查询，返回一个对象
	GetByIDX(ctx context.Context,{{.PrimaryKey.Col}} {{.PrimaryKey.Type}}, cols ...dialect.Field) (*{{$package}}.{{$structName}}, bool, error)
	// Get 按条件读取一个对象
	GetX(ctx context.Context, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error)
{{- end}}
	// GetFirstCell 按条件读取第一行的第一个字段
	GetFirstCell(ctx context.Context,col dialect.Field, cond ...dialect.Condition) (any, bool, error)
	//
	IDs(ctx context.Context, cond ...dialect.Condition) ([]any, error)
	//
	Columns(ctx context.Context, col dialect.Field, cond ...dialect.Condition) ([]any, error)
}

type dao{{$structName}} struct {
	db    ace.Executer
{{- if .HasCache}}
	cache cachego.Cache
	sg singleflight.Group
{{- end}}
}

func {{$structName}}(exec ace.Executer) {{$tablename}}er {
	obj := &dao{{$structName}}{}
	obj.db = exec
{{- if .HasCache}}
	obj.cache = exec.Cache({{$package}}.{{$structName}}TableName)
{{- end}}
	return obj
}

// C Create {{$tablename}}
func (p *dao{{$structName}}) C() *ace.Creator {
	return p.db.C({{$package}}.{{$structName}}TableName)
}

// R Read {{$tablename}}
func (p *dao{{$structName}}) R() *ace.Selector{
	return p.db.R({{$package}}.{{$structName}}TableName)
}

// U Update {{$tablename}}
func (p *dao{{$structName}}) U() *ace.Updater{
	return p.db.U({{$package}}.{{$structName}}TableName)
}

// D Delete {{$tablename}}
func (p *dao{{$structName}}) D() *ace.Deleter{
	return p.db.D({{$package}}.{{$structName}}TableName)
}


// Insert 返回 LastInsertId
func (p *dao{{$structName}}) Insert(ctx context.Context, sets ...dialect.Setter) (int64, error) {
	if len(sets) == 0 {
		return 0, dialect.ErrSetterEmpty
	}
	result, err := p.C().
	    Set(sets...).
	    Exec(ctx)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

// InsertOne 返回 LastInsertId
// cols: 要插入的列名
func (p *dao{{$structName}}) InsertOne(ctx context.Context, bean *{{$package}}.{{$structName}}, cols ...dialect.Field) (bool, error) {
	result, err := p.C().
	    Cols(cols...).
	    Struct(ctx, bean)
	if err != nil {
		return false, err
	}

    bean.AssignPrimaryKeyValues(result)

	n, err := result.RowsAffected()
	return n > 0, err
}

// InsertBatch 批量插入,返回 RowsAffected。禁止在事务中使用
// cols: 要插入的列名
func (p *dao{{$structName}}) InsertBatch(ctx context.Context, beans []*{{$package}}.{{$structName}}, cols ...dialect.Field) (int64, error) {
	lens := len(beans)
	if lens == 0 {
		return 0, dialect.ErrBeanEmpty
	}
	args := make([]dialect.Modeler, 0, lens)
	for _, bean := range beans {
		args = append(args, bean)
	}
	result, err := p.C().
	    Cols(cols...).
	    StructBatch(ctx, args...)
	if err != nil {
		return 0, err
	}

	return result.RowsAffected()
}

// Update
func (p *dao{{$structName}}) Update(ctx context.Context, sets []dialect.Setter, cond ...dialect.Condition) (bool, error) {
	if len(sets) == 0 {
		return false, dialect.ErrSetterEmpty
	}
	result, err := p.U().
	    Where(cond...).
	    Set(sets...).
	    Exec(ctx)
	if err != nil {
		return false, err
	}
	n, err := result.RowsAffected()
	return n >= 0, err
}

// UpdateById
func (p *dao{{$structName}}) UpdateById(ctx context.Context,{{.PrimaryKey.Col}} {{.PrimaryKey.Type}}, sets ...dialect.Setter) (bool, error) {
    return p.Update(ctx,
        sets,
       	tbl{{$tbl}}.PrimaryKey.Eq({{.PrimaryKey.Col}}),
    )
}

// UpdateBatch 批量更新,禁止在事务中使用
// cols: 要更新的列名
func (p *dao{{$structName}}) UpdateBatch(ctx context.Context, beans []*{{$package}}.{{$structName}}, cols ...dialect.Field) (bool, error) {
	lens := len(beans)
	if lens == 0 {
		return false, dialect.ErrBeanEmpty
	}
	args := make([]dialect.Modeler, 0, lens)
	for _, bean := range beans {
		args = append(args, bean)
	}
	result, err := p.U().
	    Cols(cols...).
	    StructBatch(ctx, args...)
	if err != nil {
		return false, err
	}
	n, err := result.RowsAffected()
	return n >= 0, err
}

// Delete
func (p *dao{{$structName}}) Delete(ctx context.Context, cond ...dialect.Condition) (bool, error) {
	result, err := p.D().
	    Where(cond...).
	    Exec(ctx)
	if err != nil {
		return false, err
	}
	n, err := result.RowsAffected()
	return n >= 0, err
}

// DeleteById
func (p *dao{{$structName}}) DeleteById(ctx context.Context, {{.PrimaryKey.Col}} {{.PrimaryKey.Type}}) (bool, error) {
    return p.Delete(ctx,
        tbl{{$tbl}}.PrimaryKey.Eq({{.PrimaryKey.Col}}),
	)
}

// Get4Cols 先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) Get4Cols(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error) {
	c := p.R()
	if len(cols) == 0 {
		c.Cols(tbl{{$tbl}}.ReadableFields...)
	} else {
		c.Cols(cols...)
	}

	row, err := c.Where(cond...).
	    QueryRow(ctx)
	if err != nil {
		return nil, false, err
	}

	obj := {{$package}}.New{{$structName}}()

	err = row.Scan(obj.AssignPtr(cols...)...)
	switch err {
	case sql.ErrNoRows:
		return nil,false, nil
	case nil:
		return obj,true, nil
	default:
		return nil,false, err
	}
}

// Find4Cols 分页获取{{.TableName}} slice对象，先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) Find4Cols(ctx context.Context, pageIndex, pageSize uint, cols []dialect.Field, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error) {
	c := p.R()
	if len(cols) == 0 {
		c.Cols(tbl{{$tbl}}.ReadableFields...)
	} else {
		c.Cols(cols...)
	}
	//
	if pageSize == 0 {
		pageSize = dialect.PageSize
	}
	//
	rows, err := c.Where(cond...).
	    Limit(pageSize, pageSize*pageIndex).
	    Query(ctx)
	if err != nil {
		return nil, false, err
	}
	defer rows.Close()

	obj := {{$package}}.New{{$structName}}()

	objs, has, err := obj.Scan(rows, cols...)
	if has {
		return objs, true, err
	}
	return nil, false, err
}

// GetByID 按主键读取一个{{.TableName}}对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) GetByID(ctx context.Context,{{.PrimaryKey.Col}} {{.PrimaryKey.Type}}, cols ...dialect.Field) (*{{$package}}.{{$structName}}, bool, error) {
{{- if .HasCache}}
	obj,has,e:=p.getCache(ctx, {{.PrimaryKey.Col}})
	if has{
		return obj,has,nil
	}

	v, e, _ := p.sg.Do(conv.Any2String({{.PrimaryKey.Col}}), func() (any, error) {
		obj, has, e = p.Get4Cols(ctx, cols, tbl{{$tbl}}.PrimaryKey.Eq({{.PrimaryKey.Col}}))
		if has {
			e = p.setCache(ctx, obj)
		}
		return obj, e
	})
	if v != nil {
		return v.(*{{$package}}.{{$structName}}), true, e
	}

	return nil,false,e
{{- else}}
	return p.Get4Cols(ctx, cols, tbl{{$tbl}}.PrimaryKey.Eq({{.PrimaryKey.Col}}))
{{- end}}
}

// Get 按条件读取一个{{.TableName}}对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) Get(ctx context.Context, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error) {
	return p.Get4Cols(ctx, []dialect.Field{}, cond...)
}

// GetFirstCell 按条件读取首行首列,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) GetFirstCell(ctx context.Context,col dialect.Field, cond ...dialect.Condition) (any, bool, error) {
	c := p.R().Cols(col)
	row, err := c.Where(cond...).QueryRow(ctx)
	if err != nil {
		return nil,false, err
	}

	var v any
	err = row.Scan(&v)
	switch err {
    case sql.ErrNoRows:
        return nil,false,nil
    case nil:
        return v,true,nil
    default:
        return nil,false,err
    }
}

// Find 按条件读取一个{{.TableName}} slice对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) Find(ctx context.Context, pageIndex, pageSize uint, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error) {
	return p.Find4Cols(ctx, pageIndex, pageSize, []dialect.Field{}, cond...)
}


// IDs
func (p *dao{{$structName}}) IDs(ctx context.Context, cond ...dialect.Condition) ([]any, error) {
	c := p.R().Cols(tbl{{$tbl}}.PrimaryKey)
	rows, err := c.Where(cond...).
	    Limit(dialect.MaxLimit).
	    Query(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	ids := make([]any, 0, dialect.PageSize)
	for rows.Next() {
	    var {{ .PrimaryKey.Col }} {{.PrimaryKey.Type}}
		if err = rows.Scan(&{{.PrimaryKey.Col}}); err != nil {
			return nil, err
		}
		ids = append(ids, {{.PrimaryKey.Col}})
	}

	return ids, rows.Err()
}

// Columns
func (p *dao{{$structName}}) Columns(ctx context.Context, col dialect.Field, cond ...dialect.Condition) ([]any, error) {
	c := p.R().Cols(col)
	rows, err := c.Where(cond...).
	    Limit(dialect.MaxLimit).
	    Query(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	cols := make([]any, 0, dialect.PageSize)
	for rows.Next() {
		var v any
		if err = rows.Scan(&v); err != nil {
			return nil, err
		}
		cols = append(cols, v)
	}
	return cols, rows.Err()
}

// Count
func (p *dao{{$structName}}) Count(ctx context.Context, cond ...dialect.Condition) (int64, error) {
	return p.R().Count(ctx, cond...)
}

// Sum
func (p *dao{{$structName}}) Sum(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (map[string]any, error) {
	return p.R().Sum(ctx, cols, cond...)
}

// Exists
func (p *dao{{$structName}}) Exists(ctx context.Context, cond ...dialect.Condition) (bool, error) {
	c := p.R().Cols(tbl{{$tbl}}.PrimaryKey).Where(cond...)
	row, err := c.QueryRow(ctx)
    if err != nil {
        return false, err
    }

	var {{ .PrimaryKey.Col }} {{.PrimaryKey.Type}}
    err = row.Scan(&{{.PrimaryKey.Col}})
    switch err {
    case sql.ErrNoRows:
        return false, nil
    case nil:
        return true, nil
    default:
        return false, err
    }
}

{{- if .HasCache}}
// onUpdate
func (p *dao{{$structName}}) onUpdate(ctx context.Context, ids ...{{.PrimaryKey.Type}}) error {
	for _, id := range ids {
		if err := p.cache.Delete(ctx, GetIdHashKey(id)); err != nil {
			return err
		}
	}

	return p.cache.PrefixDelete(ctx, "s:")
}

// getCache
func (p *dao{{$structName}}) getCache(ctx context.Context, {{.PrimaryKey.Col}} {{.PrimaryKey.Type}}) (*{{$package}}.{{$structName}}, bool, error) {
	s,err := p.cache.Fetch(ctx, GetIdHashKey({{.PrimaryKey.Col}}))
	if err != nil {
		return nil, false, err
	}
	if len(s)==0 {
		return nil, false, nil
	}
	obj := {{$package}}.New{{$structName}}()
	err = json.Unmarshal(s, obj)
	if err != nil {
		return nil, false, err
	}
	return obj, true,nil
}

// setCache
func (p *dao{{$structName}}) setCache(ctx context.Context, obj *{{$package}}.{{$structName}}) error {
	s,err := json.Marshal(obj)
	if err != nil {
		return err
	}
	return p.cache.Save(ctx, GetIdHashKey(obj.{{.PrimaryKey.Name}}), string(s), {{.CacheData}})
}
{{end}}

{{- if ne .RelationX.Name ""}}

//////////////

// Find 按条件读取一个{{.TableName}} slice对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) FindX(ctx context.Context, pageIndex, pageSize uint, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error) {
	return p.Find4ColsX(ctx, pageIndex, pageSize, []dialect.Field{}, cond...)
}
// Get4Cols 先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) Get4ColsX(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error) {
	c := p.R()
	if len(cols) == 0 {
		c.Cols(tbl{{$tbl}}.ReadableFields...)
	} else {
		c.Cols(cols...)
	}

	row, err := c.Where(cond...).
		QueryRow(ctx)
	if err != nil {
		return nil, false, err
	}

	obj := {{$package}}.New{{$structName}}()

	err = row.Scan(obj.AssignPtr(cols...)...)
	switch err {
	case sql.ErrNoRows:
		return nil, false, nil
	case nil:
		rs := p.edges(ctx,[]any{obj.{{.RelationX.Field}}})
		if len(rs) > 0{
{{- if eq .RelationX.Kind "slice"}}
			obj.{{.RelationX.Name}} = rs[obj.{{.RelationX.Field}}]
{{- else if eq .RelationX.Kind "ptr"}}
			tmp := rs[obj.{{.RelationX.Field}}][0]
			obj.{{.RelationX.Name}} = &tmp
{{- else}}
			obj.{{.RelationX.Name}} = rs[obj.{{.RelationX.Field}}][0]
{{- end}}
		}
		return obj, true, nil
	default:
		return nil, false, err
	}
}

// edges
func (p *dao{{$structName}}) edges(ctx context.Context,ids []any) map[any][]{{$package}}.{{.RelationX.Type}} {
	rsMap := make(map[any][]{{$package}}.{{.RelationX.Type}}, len(ids))
	rs, has, _ := {{.RelationX.Type}}(p.db).Find(ctx, 0, 0, tbl{{lower (.RelationX.Type)}}.{{.RelationX.Foreign}}.In(ids...))
	if !has {
		return rsMap
	}
	for _, r := range rs {
		rsMap[r.{{.RelationX.Foreign}}] = append(rsMap[r.{{.RelationX.Foreign}}], r)
	}
	return rsMap
}

// Find4Cols 分页获取{{.TableName}} slice对象，先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) Find4ColsX(ctx context.Context, pageIndex, pageSize uint, cols []dialect.Field, cond ...dialect.Condition) ([]{{$package}}.{{$structName}}, bool, error) {
	c := p.R()
	if len(cols) == 0 {
		c.Cols(tbl{{$tbl}}.ReadableFields...)
	} else {
		c.Cols(cols...)
	}
	//
	if pageSize == 0 {
		pageSize = dialect.PageSize
	}
	//
	rows, err := c.Where(cond...).
		Limit(pageSize, pageSize*pageIndex).
		Query(ctx)
	if err != nil {
		return nil, false, err
	}
	defer rows.Close()

	obj := {{$package}}.New{{$structName}}()

	objs, has, err := obj.Scan(rows, cols...)
	if has {
		ids := make([]any, 0, len(objs))
		l := len(objs)
		for i := 0; i < l; i++ {
			ids = append(ids, objs[i].{{.RelationX.Field}})
		}
		if len(ids) == 0 {
			return objs, true, err
		}
		rs := p.edges(ctx, ids)
		if len(rs) > 0 {
			for i := 0; i < l; i++ {
			{{- if eq .RelationX.Kind "slice"}}
				objs[i].{{.RelationX.Name}} = rs[objs[i].{{.RelationX.Field}}]
			{{- else if eq .RelationX.Kind "ptr"}}
				tmp := rs[objs[i].{{.RelationX.Field}}][0]
				objs[i].{{.RelationX.Name}} = &tmp
			{{- else}}
				objs[i].{{.RelationX.Name}} = rs[objs[i].{{.RelationX.Field}}][0]
			{{- end}}
			}
		}
		return objs, true, err
	}
	return nil, false, err
}

// GetByID 按主键读取一个{{.TableName}}对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) GetByIDX(ctx context.Context, id types.BigInt, cols ...dialect.Field) (*{{$package}}.{{$structName}}, bool, error) {
	return p.Get4ColsX(ctx, cols, tbl{{$tbl}}.PrimaryKey.Eq(id))
}

// Get 按条件读取一个{{.TableName}}对象,先判断第二返回值是否为true,再判断是否第三返回值为nil
func (p *dao{{$structName}}) GetX(ctx context.Context, cond ...dialect.Condition) (*{{$package}}.{{$structName}}, bool, error) {
	return p.Get4ColsX(ctx, []dialect.Field{}, cond...)
}
{{- end}}