// Code generated by github.com/linbaozhong/gentity. DO NOT EDIT.

{{- $tablename := .TableName}}
{{- $structName := .StructName}}
{{- $structNameLower := lower .StructName}}

package dao

import (
	"context"
	"database/sql"
	"{{.ModulePath}}/{{.PackageName}}"
	"{{.ModulePath}}/define/table/{{$structNameLower}}tbl"
	"github.com/linbaozhong/gentity/pkg/ace"
	"github.com/linbaozhong/gentity/pkg/ace/dialect"
	atype "github.com/linbaozhong/gentity/pkg/ace/types"
)

type {{.StructName}}Daoer interface {
	dialect.Daoer
	ace.Cruder
	// InsertOne 插入一条数据，返回 LastInsertId
	// cols: 要插入的列名
	InsertOne(ctx context.Context, bean *{{.PackageName}}.{{.StructName}}, cols ...dialect.Field) (int64, error)
	// InsertBatch 批量插入多条数据,返回 RowsAffected
	// cols: 要插入的列名
	InsertBatch(ctx context.Context, beans []*{{.PackageName}}.{{.StructName}}, cols ...dialect.Field) (int64, error)
    // UpdateById 按主键更新一条数据
    UpdateById(ctx context.Context, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}} any, sets ...dialect.Setter) (bool, error)
	// UpdateBatch 批量更新多条数据
	// cols: 要更新的列名
	UpdateBatch(ctx context.Context, beans []*{{.PackageName}}.{{.StructName}}, cols ...dialect.Field) (bool, error)
	// DeleteById 按主键删除一条数据
    DeleteById(ctx context.Context, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}} any) (bool, error)
	// Find4Cols 分页查询指定列，返回一个slice
	Find4Cols(ctx context.Context, pageIndex, pageSize uint, cols []dialect.Field, cond ...dialect.Condition) ([]*{{.PackageName}}.{{.StructName}}, bool, error)
	// Find 分页查询，返回一个slice
	Find(ctx context.Context, pageIndex, pageSize uint, cond ...dialect.Condition) ([]*{{.PackageName}}.{{.StructName}}, bool, error)
	// Get4Cols 读取一个对象的指定列
	Get4Cols(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (*{{.PackageName}}.{{.StructName}}, bool, error)
	// GetByID 按主键查询，返回一个对象
	GetByID(ctx context.Context, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}} any, cols ...dialect.Field) (*{{.PackageName}}.{{.StructName}}, bool, error)
	// Get 按条件读取一个对象
	Get(ctx context.Context, cond ...dialect.Condition) (*{{.PackageName}}.{{.StructName}}, bool, error)
	// GetFirstCell 按条件读取第一行的第一个字段
	GetFirstCell(ctx context.Context,col dialect.Field, cond ...dialect.Condition) (any, bool, error)
	//
	IDs(ctx context.Context, cond ...dialect.Condition) ([]any, error)
	//
	Columns(ctx context.Context, col dialect.Field, cond ...dialect.Condition) ([]any, error)
}

type {{.TableName}}Dao struct {
	db    ace.Executer
}

func {{.StructName}}(exec ace.Executer) {{$structName}}Daoer {
	return &{{.TableName}}Dao{db: exec}
}

// C Create {{ .TableName }}
func (p *{{.TableName}}Dao) C() *ace.Creator {
	return p.db.C({{.PackageName}}.{{$structName}}TableName)
}

// R Read {{ .TableName }}
func (p *{{.TableName}}Dao) R() *ace.Selector{
	return p.db.R({{.PackageName}}.{{$structName}}TableName)
}

// U Update {{ .TableName }}
func (p *{{.TableName}}Dao) U() *ace.Updater{
	return p.db.U({{.PackageName}}.{{$structName}}TableName)
}

// D Delete {{ .TableName }}
func (p *{{.TableName}}Dao) D() *ace.Deleter{
	return p.db.D({{.PackageName}}.{{$structName}}TableName)
}


// Insert 返回 LastInsertId
func (p *{{.TableName}}Dao) Insert(ctx context.Context, sets ...dialect.Setter) (int64, error) {
	if len(sets) == 0 {
		return 0, atype.ErrSetterEmpty
	}
	result, err := p.C().
	    Set(sets...).
	    Exec(ctx)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

// InsertOne 返回 LastInsertId
// cols: 要插入的列名
func (p *{{.TableName}}Dao) InsertOne(ctx context.Context, bean *{{.PackageName}}.{{.StructName}}, cols ...dialect.Field) (int64, error) {
	result, err := p.C().
	    Cols(cols...).
	    Struct(ctx, bean)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

// InsertBatch 批量插入,返回 RowsAffected
// cols: 要插入的列名
func (p *{{.TableName}}Dao) InsertBatch(ctx context.Context, beans []*{{.PackageName}}.{{.StructName}}, cols ...dialect.Field) (int64, error) {
	lens := len(beans)
	if lens == 0 {
		return 0, atype.ErrBeanEmpty
	}
	args := make([]dialect.Modeler, 0, lens)
	for _, bean := range beans {
		args = append(args, bean)
	}
	result, err := p.C().
	    Cols(cols...).
	    Struct(ctx, args...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// Update
func (p *{{.TableName}}Dao) Update(ctx context.Context, sets []dialect.Setter, cond ...dialect.Condition) (bool, error) {
	if len(sets) == 0 {
		return false, atype.ErrSetterEmpty
	}
	result, err := p.U().
	    Where(cond...).
	    Set(sets...).
	    Exec(ctx)
	if err != nil {
		return false, err
	}
	n, err := result.RowsAffected()
	return n >= 0, err
}

// UpdateById
func (p *{{.TableName}}Dao) UpdateById(ctx context.Context, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}} any, sets ...dialect.Setter) (bool, error) {
    return p.Update(ctx,
        sets,
        {{- range $key,$value := .Keys}}
        {{- if gt $key 0}},{{end}}{{$structNameLower}}tbl.{{index $value 0}}.Eq({{index $value 1}})
        {{- end}})
}

// UpdateBatch
// cols: 要更新的列名
func (p *{{.TableName}}Dao) UpdateBatch(ctx context.Context, beans []*{{.PackageName}}.{{.StructName}}, cols ...dialect.Field) (bool, error) {
	lens := len(beans)
	if lens == 0 {
		return false, atype.ErrBeanEmpty
	}
	args := make([]dialect.Modeler, 0, lens)
	for _, bean := range beans {
		args = append(args, bean)
	}
	result, err := p.U().
	    Cols(cols...).
	    Struct(ctx, args...)
	if err != nil {
		return false, err
	}
	n, err := result.RowsAffected()
	return n >= 0, err
}

// Delete
func (p *{{.TableName}}Dao) Delete(ctx context.Context, cond ...dialect.Condition) (bool, error) {
	result, err := p.D().
	    Where(cond...).
	    Exec(ctx)
	if err != nil {
		return false, err
	}
	n, err := result.RowsAffected()
	return n >= 0, err
}

// DeleteById
func (p *{{.TableName}}Dao) DeleteById(ctx context.Context, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}} any) (bool, error) {
    return p.Delete(ctx,
        {{- range $key,$value := .Keys}}
        {{- if gt $key 0}},{{end}}{{$structNameLower}}tbl.{{index $value 0}}.Eq({{index $value 1}})
        {{- end}})
}

// Get4Cols
func (p *{{.TableName}}Dao) Get4Cols(ctx context.Context, cols []dialect.Field, cond ...dialect.Condition) (*{{.PackageName}}.{{.StructName}}, bool, error) {
	c := p.R()
	if len(cols) == 0 {
		c.Cols({{$structNameLower}}tbl.ReadableFields...)
	} else {
		c.Cols(cols...)
	}

	row, err := c.Where(cond...).
	    QueryRow(ctx)
	if err != nil {
		return nil, false, err
	}

	obj := {{.PackageName}}.New{{.StructName}}()
	defer obj.Free()

	err = row.Scan(obj.AssignPtr(cols...)...)
	switch err {
	case sql.ErrNoRows:
		return nil,false, nil
	case nil:
		return obj,true, nil
	default:
		return nil,false, err
	}
}
//
// Find4Cols
func (p *{{.TableName}}Dao) Find4Cols(ctx context.Context, pageIndex, pageSize uint, cols []dialect.Field, cond ...dialect.Condition) ([]*{{.PackageName}}.{{.StructName}}, bool, error) {
	c := p.R()
	if len(cols) == 0 {
		c.Cols({{$structNameLower}}tbl.ReadableFields...)
	} else {
		c.Cols(cols...)
	}
	//
	if pageSize == 0 {
		pageSize = atype.PageSize
	}
	//
	rows, err := c.Where(cond...).
	    Limit(pageSize, pageSize*pageIndex).
	    Query(ctx)
	if err != nil {
		return nil, false, err
	}
	defer rows.Close()

	obj := {{.PackageName}}.New{{.StructName}}()
	defer obj.Free()

	objs, has, err := obj.Scan(rows, cols...)
	if err != nil {
		return nil, false, err
	}
	return objs, has, nil
}

// GetByID Read one {{.TableName}} By Primary Key value,
// Pass values in this order：{{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}}
func (p *{{.TableName}}Dao) GetByID(ctx context.Context, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}} any, cols ...dialect.Field) (*{{.PackageName}}.{{.StructName}}, bool, error) {
	return p.Get4Cols(ctx, cols, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{$structNameLower}}tbl.{{index $value 0}}.Eq({{index $value 1}}){{ end}})
}

// Get Read one {{.TableName}}
func (p *{{.TableName}}Dao) Get(ctx context.Context, cond ...dialect.Condition) (*{{.PackageName}}.{{.StructName}}, bool, error) {
	return p.Get4Cols(ctx, []dialect.Field{}, cond...)
}

// GetFirstCell Read the first column of the first row
func (p *{{.TableName}}Dao) GetFirstCell(ctx context.Context,col dialect.Field, cond ...dialect.Condition) (any, bool, error) {
	c := p.R().Cols(col)
	row, err := c.Where(cond...).QueryRow(ctx)
	if err != nil {
		return nil,false, err
	}

	var v any
	err = row.Scan(&v)
	switch err {
    case sql.ErrNoRows:
        return nil,false,nil
    case nil:
        return v,true,nil
    default:
        return nil,false,err
    }
}

// Find
func (p *{{.TableName}}Dao) Find(ctx context.Context, pageIndex, pageSize uint, cond ...dialect.Condition) ([]*{{.PackageName}}.{{.StructName}}, bool, error) {
	return p.Find4Cols(ctx, pageIndex, pageSize, []dialect.Field{}, cond...)
}


// IDs
func (p *{{.TableName}}Dao) IDs(ctx context.Context, cond ...dialect.Condition) ([]any, error) {
	c := p.R().Cols({{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{$structNameLower}}tbl.{{index $value 0}}{{ end}})
	rows, err := c.Where(cond...).
	    Limit(atype.MaxLimit).
	    Query(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	ids := make([]any, 0, atype.PageSize)
	for rows.Next() {
	{{- range $key,$value := .Keys}}
	    var {{ index $value 1 }} {{index $value 2}}
	{{- end}}
		if err = rows.Scan({{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}&{{index $value 1}}{{ end}}); err != nil {
			return nil, err
		}
		ids = append(ids, {{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{index $value 1}}{{ end}})
	}

	return ids, rows.Err()
}

// Columns
func (p *{{.TableName}}Dao) Columns(ctx context.Context, col dialect.Field, cond ...dialect.Condition) ([]any, error) {
	c := p.R().Cols(col)
	rows, err := c.Where(cond...).
	    Limit(atype.MaxLimit).
	    Query(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	cols := make([]any, 0, atype.PageSize)
	for rows.Next() {
		var v any
		if err = rows.Scan(&v); err != nil {
			return nil, err
		}
		cols = append(cols, v)
	}
	return cols, rows.Err()
}

// Count
func (p *{{.TableName}}Dao) Count(ctx context.Context, cond ...dialect.Condition) (int64, error) {
	return p.R().Count(ctx, cond...)
}

// Sum
func (p *{{.TableName}}Dao) Sum(ctx context.Context, col dialect.Field, cond ...dialect.Condition) (int64, error) {
	return p.R().Sum(ctx, col, cond...)
}

// Exists
func (p *{{.TableName}}Dao) Exists(ctx context.Context, cond ...dialect.Condition) (bool, error) {
	c := p.R().Cols({{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}{{$structNameLower}}tbl.{{index $value 0}}{{ end}}).Where(cond...)
	row, err := c.QueryRow(ctx)
    if err != nil {
        return false, err
    }

	{{- range $key,$value := .Keys}}
	var {{ index $value 1 }} {{index $value 2}}
	{{- end}}
    err = row.Scan({{ range $key,$value := .Keys}}{{if gt $key 0}},{{end}}&{{index $value 1}}{{ end}})
    switch err {
    case sql.ErrNoRows:
        return false, nil
    case nil:
        return true, nil
    default:
        return false, err
    }
}
